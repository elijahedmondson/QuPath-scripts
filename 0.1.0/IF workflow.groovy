//STEP 1
//Once your nucleus detection is settled using Cell Detection, replace the second line of code with your own

createSelectAllObject(true);

runPlugin('qupath.imagej.detect.nuclei.WatershedCellDetection', '{"detectionImageFluorescence": 1,  "requestedPixelSizeMicrons": 0.5,  "backgroundRadiusMicrons": 0.0,  "medianRadiusMicrons": 1.0,  "sigmaMicrons": 2.5,  "minAreaMicrons": 10.0,  "maxAreaMicrons": 400.0,  "threshold": 8000.0,  "watershedPostProcess": true,  "cellExpansionMicrons": 0.0,  "includeNuclei": true,  "smoothBoundaries": true,  "makeMeasurements": true}');

//STEP 2
//BEFORE running step 2, draw your cytoplasmic areas with the annotation drawing tools in QuPath.  Once you are set, you should
//be able to run this script in order to merge the cytoplasms with the nuclei to create cells.  This will not work if the
//cytoplasms cross outside of the area defined by the largest annotation object.

//At the end it generates some cell shape measurements.

import qupath.lib.objects.PathCellObject

// Get the current hierarchy
def hierarchy = getCurrentHierarchy()

// Get the select objects

def targets = getObjects{return it.getLevel()!=1 && it.isAnnotation()}


// Check we have anything to work with
if ( targets.isEmpty()) {
    print("No objects selected!")
    return
}

// Loop through objects
def newDetections = new ArrayList<>()
for (def cellAnnotation in  targets) {

    // Unlikely to happen... but skip any objects not having a ROI
    if (!cellAnnotation.hasROI()) {
        print("Skipping object without ROI: " + cellAnnotation)
        continue
    }
    def nucleus = hierarchy.getDescendantObjects(cellAnnotation, null, null)
    def roiNuc = nucleus[0].getROI()
    def roiCyto =  cellAnnotation.getROI()
    def nucMeasure = nucleus[0].getMeasurementList()
    def cell = new PathCellObject(roiCyto,roiNuc,cellAnnotation.getPathClass(),nucMeasure)
    newDetections.add(cell)
    print("Adding " + cell)

    
    //remove stand alone nucleus
    removeObject(nucleus[0], true)
}
removeObjects( targets, true)
// Actually add the objects
hierarchy.addPathObjects(newDetections, false)

fireHierarchyUpdate()
if (newDetections.size() > 1)
    print("Added " + newDetections.size() + " detections(s)")
    
selectDetections()
runPlugin('qupath.lib.plugins.objects.ShapeFeaturesPlugin', '{"area": true,  "perimeter": true,  "circularity": true,  "useMicrons": true}');

//STEP 3
//Finally, add some measurements to the cell that would allow you to classify them more easily than the whole cell measurements
//generated by the Add Intensity Features command

//Calculate the mean cytoplasmic intensities in an IF image base on nuclear intensities and whole cell intensities

import qupath.lib.objects.*
  
def addColors(){
runPlugin('qupath.lib.algorithms.IntensityFeaturesPlugin', '{"pixelSizeMicrons": '+getCurrentImageData().getServer().getPixelWidthMicrons()+',  "region": "ROI",  "tileSizeMicrons": 25.0,  "channel1": true,  "channel2": true,  "channel3": true, "channel4": true,  "doMean": true,  "doStdDev": false,  "doMinMax": false,  "doMedian": false,  "doHaralick": false,  "haralickDistance": 1,  "haralickBins": 32}');

}

//The only thing beyond this point that should need to be modified is the removalList command at the end, which you can disable
//if you wish to keep whole cell measurements

// Get cells & create temporary nucleus objects - storing link to cell in a map
def cells = getCellObjects()
def map = [:]
for (cell in cells) {
	def detection = new PathDetectionObject(cell.getNucleusROI())
	map[detection] = cell
}

// Get the nuclei as a list
def nuclei = map.keySet() as List
// and then select the nuclei
getCurrentHierarchy().getSelectionModel().setSelectedObjects(nuclei, null)

// Add as many sets of color deconvolution stains and Intensity features plugins as you want here
//This section ONLY adds measurements to the temporary nucleus objects, not the cell
addColors()

//etc etc. make sure each set has different names for the stains or else they will overwrite

// Don't need selection now
clearSelectedObjects()

// Can update measurements generated for the nucleus to the parent cell's measurement list
for (nucleus in nuclei) {
    def cell = map[nucleus]
    def cellMeasurements = cell.getMeasurementList()
    for (key in nucleus.getMeasurementList().getMeasurementNames()) {
        double value = nucleus.getMeasurementList().getMeasurementValue(key)
        def listOfStrings = key.tokenize(':')     
        def baseValueName = listOfStrings[-2]+listOfStrings[-1]
        nuclearName = "Nuclear" + baseValueName
        cellMeasurements.putMeasurement(nuclearName, value)
    }
    cellMeasurements.closeList()
}

//I want to remove the original whole cell measurements which contain the mu symbol
// Not yet sure I will find the whole cell useful so not adding it back in yet.
def removalList = []

//Create whole cell measurements for all of the above stains
selectDetections()

addColors()

//Create cytoplasmic measurements by subtracting the nuclear measurements from the whole cell, based total intensity (mean value*area)
for (cell in cells) {

   //A mess of things I could probably call within functions
   def cellMeasurements = cell.getMeasurementList()
   double cellArea = cell.getMeasurementList().getMeasurementValue("Cell Shape: Area ?m^2")
   double nuclearArea = cell.getMeasurementList().getMeasurementValue("Nucleus Shape: Area ?m^2")
   double cytoplasmicArea = cellArea-nuclearArea
   

   for (key in cell.getMeasurementList().getMeasurementNames()) {
           //check if the value is one of the added intensity measurements
        if (key.contains("per pixel")){
            //check if we already have this value in the list.
            //probably an easier way to do this outside of every cycle of the for loop
            if (!removalList.contains(key)) removalList<<key
            double value = cell.getMeasurementList().getMeasurementValue(key)
            //calculate the sum of the OD measurements
            cellOD = value * cellArea
            
            //break each measurement into component parts, then take the last two 
            // which will usually contain the color vector and "mean"
            def listOfStrings = key.tokenize(':')          
            def baseValueName = listOfStrings[-2]+listOfStrings[-1]
            //access the nuclear value version of the base name, and use it and the whole cell value to
            //calcuate the rough cytoplasmic value
            def cytoplasmicKey = "Cytopasmic" + baseValueName
            def nuclearKey = "Nuclear" + baseValueName
            def nuclearOD = nuclearArea * cell.getMeasurementList().getMeasurementValue(nuclearKey)

            def cytoplasmicValue = (cellOD - nuclearOD)/cytoplasmicArea
            cellMeasurements.putMeasurement(cytoplasmicKey, cytoplasmicValue)
            cellMeasurements.putMeasurement("Cytoplasm Shape: Area ?m^2", cytoplasmicArea)
        }
    }
    cellMeasurements.closeList()
}
removalList.each {println(it)}

//comment out this line if you want the whole cell measurements.
removalList.each {removeMeasurements(qupath.lib.objects.PathCellObject, it)}
//************************************************************//

fireHierarchyUpdate()
println "Done!"


//SAVE ANNOTATIONS //

def name = getProjectEntry().getImageName() + '.txt'
//def path = buildFilePath('C:/Users/edmondsonef/Desktop/QuPath/', 'annotation results')
mkdirs(path)
path = buildFilePath(path, name)
saveAnnotationMeasurements(path)